= Black Boxes and Procedural Abstraction

== Subroutines

* 어떤 작업을 수행하기 위한 명령어들을 덩어리로 묶음

* 복잡한 하나의 작업을 간단한 하나의 개념으로 처리

* 복잡성을 다루는 도구


===== BlackBox

* subroutine과 같은 개념. -> 외부에서 내부를 볼 수 없다.(볼 필요가 없다.)

* 블랙박스는 외부와의 교류조차 불가능함.

** 블랙박스는 Interface의 한 종류를 필요로 한다 -> 안과 밖의 적당한 상호작용

*** ex1) 버튼 -> 해당 버튼에 맞는 업무 수행

*** ex2) 다이얼 -> 설정 변경

*** 다이얼과 버튼은 외부와 상호작용 하는 인터페이스

> BlackBox의 규칙 1. 블랙박스의 인터페이스는 매우 직관적이고, 잘 정의되며, 이해하기 쉬워야 한다.

> BlackBox의 규칙 2. 블랙박스를 사용하려면, 그 구현(Implementation)에 대해 알 필요는 없다. 인터페이스를 아는것만으로 충분하다.

* 사실, 밖에서 보여지는 박스의 행동 변화가 없는 한 구현은 변할 수 있다

* 서브루틴을 사용하는 프로그램에 영향을 끼치지 않고, 더 효율적인 코드가 되기 위해선, 서브루틴의 내부를 수정할 수 있어야 함

* 블랙박스를 가지기 위해선, 누군가가 애초에 구현을 설계하고, 구축했어야 한다.

* 블랙박스 사용자나 설계자 모두에게 득이 되게 작용한다.

** 다양하게 제한없이 블랙박스는 사용될 수 있다.

** 블랙박스는 한번 구현해놓으면 이후 구현할 필요가 없다.

* 블랙박스 구현자는 확실하게 작동하는지, 외부에 올바른 인터페이스를 제공하는지 보장해야 한다.

> BlackBox의 규칙 3. 블랙박스 구현자는 박스를 사용할 대형 시스템에 대해 알 필요가 없어야 한다.

* 블랙박스는 세계를 2개의 파트로 나눈다: 내부와 외부 // interface는 내부와 외부 경계면에 존재하고 두 세계를 연결

* 그런데,인터페이스를 단지 외부와 내부세계의 물리적인 연결이라고 생각하면 안된다.

** 인터페이스는 어떤 박스가 어떻게 물리적인 인터페이스 요소에 의해 제어되는지에 대한 Specification(명세)를 포함한다.

 ex) TV에 전원 스위치가 있다는 것 뿐 아니라, Tv를 키고 끄는데 전원 스위치가 사용된다는 점을 명시할 필요가 있다.

** 이를 컴퓨터 용어로 표현하자면, subroutine의 인터페이스는 의미적으로나 구문적인 요소 또한 가진다는 것이다.

** 의미론 요소는 어떤 업무가 서브루틴을 수행하는지를 정확하게 명시하는것이다.

** 이런게 합법인 프로그램을 작성하기 위해선, 서브루틴의 문법 명시를 알 필요가 있다. -- 개발 측면

** 서브루틴의 목적을 이해하고, 효율적으로 사용하기 위해서, 서브루틴의 의미론적인 명시를 알 필요가 있다. -- 사용 측면

** 인터페이스의 두 부분 — 구문적 요소와 의미론적 요소 — 을 집합적으로 서브루틴의 계약(contract)이라 언급할 것이다.

* 서브루틴에서의 계약은 기본적으로 "나를 사용하기 위해서 당신이 해야할 일이 여기에 있고, 내가 당신을 위해서 할 일이 여기에 있음을 보장한다." 는것을 얘기한다

** 서브루틴을 작성할때, 서브루틴에 대한 주석들은 위에서 얘기한 계약이 상당히 깔끔하게 만들어져야 한다.

--
++ 추가할 내용 있음


